# ==================11/3/2025===============

Finished testing the barometer. It finally works. There were a few timing and mode issues but I was able to get it to work now that I actually had some time to chill and get it done. Right now when you poll the barometer it adds an extra 0.01 seconds to the loop timer. I could add an extra mode and speed it up but I don't think it's worth it. It works and 0.01 seconds is not a huge amount of time. Right now the main loop is only 0.0046 seconds. I should keep that in mind when running the C++ version and seeing how long it takes to run that loop. What I'll do is make a note of the 0.01 seconds in the comments and change it if needed.

Anyway, next step is to test the GPS module which I believe Aramis tested and it worked after he got the polling time sleeps to work. 

# ==================10/30/2025==============

Finished testing the IMU and implementing Aramis' AHRS filter. I tested roll pitch and yaw as well as the angular velocities and made sure to convert to deg/s. It all works now which is nice. Next step is the barometer. Note I also crossed off the controller because I tested the logic already for the airplane. The waypoint or even inner loop controller for the airplane is not tested but the logic is there so you would just need to ground test that when you're ready. 

# ==================10/20/2025==============

Finished testing the PWM signals. Had to edit quite a bit but it all works now. I also used the airplane code since I wanted to test all 4 servos. So I have 1 ESC for throttle and 3 servos for the rest of the airplane. Autopilot also works as well. Next step is the IMU

# ==================10/13/2025==============

Finished testing the LEDs. Turns out the arming switch logic was a bit complex. This is what I have. 

Red - disarmed
Yellow - trying to arm but throttle is high
Green - armed and manual control
Blue - armed and autopilot control

So the LED works and the arming logic is where I want it to be where the system won't arm unless throttle is low and you can't accidentally disarm by hitting the autopilot switch since they are different channels. 

Also changed the RCIN num_channels to 6 instead of 9 since that's just unneccessry. 

Next hardware test is to test the servos. That will require power to the servo rail which needs a battery. Shouldn't be a problem as there is a battery on the desk. 

# ===================9/24/2025==============

Started testing the fast.py script on RPI and got the TX and RX to work properly. You need to setup the TX properly to get all the channels to work properly. Now on to the next hardware test. 

# ===================9/22/2025==============

Hello again. Took me a while to actually get back in here and code. Currently working on combining car.py, plane.py and boat.py into one large fast.py script. It currently works in SIL mode on a fresh install of ubuntu and I edited the readme to reflect subtle issues I ran into. 

# ===================3/18/2025==============

I have not touched the software in almost 2 years. However I had 3 students work on FASTCASST
this past year

1. One student worked on car.py in src
2. another student worked on plane.py in src
3. the last student worked on the x8_controller.cpp in the V_x8 folder

tasks have been added to reflect that

# ===================5/11/2023==============

Alright the LPS22 is up and runnning in FASTCASST
and the BNO055 is up and running in FASTCASST....independently 
(Right, forgot to mention that I found a BNO055 in the lab. Had to desolder it and resolder it but it's on the breadboard now)

Well hang on. If you compile everything independently it works. 

If you try to compile everything all at once it throws an error and says
the ino is too big.

But success!!! We now have two new sensors that are way better and more accurate. 

This means we can redo the 1 hour test and get some better sensor readings. 

--------------___Takeaways_____-------------------

1.) LPS22 give about 0.5 meter accurate altitude, same with MS5611
2.) MPL115A2 is too terrible with accuracy of 8 meters. Not possible
3.) MPU and BNO give readings accurate to about 0.05 degrees and rates at 0.1 rad/s

I think it's safe to proceed at this point - (Adding these sensor errors to the code)

-----------------__RAW DATA_____--------------------------

LPS22 - 5/11/2023 on Arduino
Pressure (Pa) 1012.718865153538 0.061805666632702594
Temperature (C) 22.807590120160217 0.07027886629646299
Pressure Altitude (m) -0.7568558077436582 0.5146848173247013

MPL115A2 - 4/25/2023 on Arduino
Pressure (Pa) 1017.6871833084947 0.9938107845505034
Pressure Altitude (m) 18.733099020088577 8.233659755177008
Temperature (C) 19.66939642324888 0.20605985540869393

MS5611 - 4/25/2023 on RPI
Sense Pressure (Pa)  1010.435000130366 0.07796213376473213
Sense Pressure Altitude (m)  0.9185693169503988 0.650793947788272
Sense Temperature (C)  29.990395402748717 1.6458100763280006


BNO055 - 5/11/2023 on Arduino
Roll (deg) -4.569886515353805 0.0016904482325902682
Pitch (deg) -2.3288050734312415 0.012813780795129794
Yaw (deg) -0.0667289719626168 0.06591945950881116
Roll Rate (rad/s) 0.001582109479305741 0.12183386880970969
Pitch Rate (rad/s) -0.0003404539385847794 0.09007609291971866
Yaw Rate (rad/s) 0.007870493991989318 0.06930855756753578

BNO055 - 4/25/2023 on Arduino
Roll (deg) -4.6899999999999995 8.881784197001252e-16
Pitch (deg) -8.760000000000002 1.7763568394002505e-15
Yaw (deg) -0.35999999999999993 5.551115123125783e-17
Roll Rate (rad/s) 0.0032637853949329353 0.12275192963650708
Pitch Rate (rad/s) -0.0014456035767511177 0.08560034127864326
Yaw Rate (rad/s) 0.011311475409836066 0.06840252892762809

MPU - 4/25/2023 on RPI
Sense Roll (deg)  -1.7413374809682711 0.045956162108804356
Sense Pitch (deg)  0.36350600401560995 0.03148911829443201
Sense Compass (deg)  -0.05332993784288219 0.03250948288852238
Sense P(rad/s)  -0.0006188019342797353 0.0032256299791546864
Sense Q(rad/s)  0.0009154440359708161 0.0023552036709843104
Sense R(rad/s)  -0.0018263469826367287 0.002249936419091247

# ===================5/8/2023===============

LSP22 is definitely a better sensor. I also attached a bread board
to the wooden drone so I can more easily plug and play sensors.

Trying to switch out the IMU for an NXP IMU and it works on an UNO
but not a DUE.

I have a bunch of LIS/LSM IMU's but the mag sensors are broken on 3 of them.
I don't really want to waste my time and solder another one.

Need an IMU for the drone so need to figure out what to do here.

===================4/26/2023==============

MPL155A2 is too terrible of a sensor for altitude. Wiring up an LSP22
to see if it's better. 

RXIN signals Digital pins 2-7

==================4/25/2023===============

Results from Arduino Datalogging Test

RXIN 0 (us) 992.0 0.0
RXIN 1 (us) 1500.0 0.0
RXIN 2 (us) 1500.0 0.0
RXIN 3 (us) 1500.0 0.0
RXIN 4 (us) 992.0 0.0
RXIN 5 (us) 992.0 0.0
PWMOUT 0 (us) 992.0 0.0
PWMOUT 1 (us) 992.0 0.0
PWMOUT 2 (us) 992.0 0.0
PWMOUT 3 (us) 992.0 0.0
PWMOUT 4 (us) 992.0 0.0
PWMOUT 5 (us) 992.0 0.0
Latitude (deg) -99.0 0.0
Longitude (deg) -99.0 0.0
Altitude (m) -99.0 0.0
Pressure (hPa) 101.76871833084948 0.09938107845505205
Pressure (Pa) 1017.6871833084947 0.9938107845505034
Pressure Altitude (m) 18.733099020088577 8.233659755177008
Temperature (C) 19.66939642324888 0.20605985540869393
Roll (deg) -4.6899999999999995 8.881784197001252e-16
Pitch (deg) -8.760000000000002 1.7763568394002505e-15
Yaw (deg) -0.35999999999999993 5.551115123125783e-17
Roll Rate (rad/s) 0.0032637853949329353 0.12275192963650708
Pitch Rate (rad/s) -0.0014456035767511177 0.08560034127864326
Yaw Rate (rad/s) 0.011311475409836066 0.06840252892762809

Results from Raspberry Pi Datalogging Test

First number is the mean and second number is the standard deviation

Sense X(m)  0.0 0.0
Sense Y(m)  0.0 0.0
Sense Z(m)  -0.9185693169503988 0.650793947788272
Sense Roll (deg)  -1.7413374809682711 0.045956162108804356
Sense Pitch (deg)  0.36350600401560995 0.03148911829443201
Sense Compass (deg)  -0.05332993784288219 0.03250948288852238
Sense U(m/s)  0.0 0.0
Sense V(m/s)  0.0 0.0
Sense W(m/s)  0.0 0.0
Sense P(rad/s)  -0.0006188019342797353 0.0032256299791546864
Sense Q(rad/s)  0.0009154440359708161 0.0023552036709843104
Sense R(rad/s)  -0.0018263469826367287 0.002249936419091247
Sense Mx(Gauss)  82.98175058469545 0.9016223501067118
Sense My(Gauss)  10.718152540749958 0.8605682337812057
Sense Mz(Gauss)  -39.37524854612296 0.8421855244877446
Sense GPS Latitude (deg)  0.0 0.0
Sense GPS Longitude (deg)  0.0 0.0
Sense GPS Altitude (m)  0.0 0.0
Sense GPS Heading (deg)  0.0 0.0
Sense IMU Heading (deg)  -53.31268702760025 97.08076224750792
Sense Analog 1 (V)  5.159999999999998 1.7763568394002505e-15
Sense Analog 2 (V)  0.033000000000000015 1.3877787807814457e-17
Sense Analog 3 (V)  0.0 0.0
Sense Analog 4 (V)  0.0 0.0
Sense Analog 5 (V)  0.023006956620100678 0.0009999758024256272
Sense Analog 6 (V)  0.02700695662010068 0.000999975802425627
Sense Pressure (Pa)  1010.435000130366 0.07796213376473213
Sense Pressure Altitude (m)  0.9185693169503988 0.650793947788272
Sense Temperature (C)  29.990395402748717 1.6458100763280006
RC Channel #1  992.0 0.0
RC Channel #2  1500.0 0.0
RC Channel #3  1500.0 0.0
RC Channel #4  1500.0 0.0
RC Channel #5  992.0 0.0
PWM Hardware Out 1  992.0 0.0
PWM Hardware Out 2  1500.0 0.0
PWM Hardware Out 3  1500.0 0.0
PWM Hardware Out 4  1500.0 0.0


==================4/5/2023================

2.) Flash code to arduino is working time to fly.
3.) Unfortunately I can't do this because the sensors are failing so we'll need to fix those sensors if we want to do that.

Remaining items 
 
4.) Fly drone manually up to altitude and log data (make sure logging data works)
5.) Plot and post process data - get sensor noise readings
6.) Run code in SIMONLY mode with realistic sensor noise and see if you can get altitude hold to work.
7.) Edit telemetry to read altitude data from another drone.
8.) Flight test again and have a ground station send it altitude commands
^^If #8 works Zach will just need to recreate what I've done 3 times and test each one

=================4/2/2023===============

Horribly hacked the controller/guidance module for quadcopter
It compiles. Need to test on hardware.
See tasks lists for more comments.

2.) Flash code to arduino
3.) Log 1 hour of data on arduino to get sensor noise
4.) Fly drone manually up to altitude and log data
5.) Plot and post process data - get sensor noise readings
6.) Run code in SIMONLY mode with realistic sensor noise and see if you can get altitude hold to work.
7.) Edit telemetry to read altitude data from another drone.
8.) Flight test again and have a ground station send it altitude commands
^^If #8 works Zach will just need to recreate what I've done 3 times and test each one

=================3/28/2023================

Ok so I think I've got the guidance module where I want it.
The problem is it's totally untested and there's a lot to test

1.) Does the code compile in SIMONLY mode? - Yes
2.) Does the code compile in SIL mode? - Yes
3.) Run the code in a variety of scenarios - Will not run right now

I have no idea what's going on so I'm backtracking on my code to see what's going on
Jan 6 - SIL works
Jan 30 - SIL works
Feb 15 - SIL works
Feb 17th - SIL works
Feb 25 - SIL works
Feb 27 - SIL does not work

Between the 25th and the 27th there were 7 commits

Newest
ba55597 - SIL dnw
97ea2b7
a8a4a50
15513f0 - won't even compile
d4407e8 - SIL dnw
49e3d3d - SIL dnw
1777a53 - SIL works
Oldest

Alright so the 1777a53 commit works but whatever I did on 49e3d3d broke it

Ok found the issue in timer.cpp. The sleep function was running and causing the code to wait forever

a.) Fully manual acro mode no guidance - check
b.) Inner Loop mode no guidance - have a toggle switch for autopilot - Check
c.) Yaw rate mode no guidance - have a toggle switch for autopilot - Check

Alright time to test guidance finally

d.) guidance is on and inner + yaw rate loop on
in this case I want the inner loop and yaw rate loops to always be on to mimic
the flight controller but then I want to be able to toggle guidance

This works!!

Now it's time to see if I can get the guidance and control module to compile on the arduino and if so it's time to flight test!!!

Wait. There's still a lot to do.

1.) Compile code on arduino
2.) Flash code to arduino
2.) Log 1 hour of data on arduino to get sensor noise
3.) Fly drone manually up to altitude and log data
4.) Plot and post process data - get sensor noise readings
5.) Run code in SIMONLY mode with realistic sensor noise and see if you can get altitude hold to work.
6.) Edit telemetry to read altitude data from another drone.
7.) Flight test again and have a ground station send it altitude commands
^^If #7 works Zach will just need to recreate what I've done 3 times and test each one

===================3/26/2023==============

All sensors are now logging. Telemetry works. Time to move to 
the flight control algorithm.

My idea is to have the guidance/ folder have a flag for the vehicle 
you want. So what changes is the physics engine?
The only problem with that is that we have all the forcemoment models in different
folders and I won't want to copy and paste.

So I think we'll have to put the guidance laws in a library since it will run for all vehicle.
Yea that's it. so perhaps move the guidance folder into the libraries folder and then select the 
quadcopter as the inner loop control law but set it to pass through or something yea that will work
or in simulation you'll have to turn on the innerloop controller since it's running on different hardware
but in AUTO mode you'll turn it off and just pass the signals to the FC.

Alright that's the plan. Here we go. 

Since we're moving straight to AUTO mode we'll just get the guidance module to run
on Arduino and put it into the libraries folder.

For simulating we'll just have to see if we have time for it.

I still want to do a:

1.) one hour logging of data and plotting for post-processing
2.) A flight test where I fly 10 feet off the ground (using telemetry) for 30 seconds and then increment up to like 100 feet and then bring her back down or do whatever I'm comfortable with.
3.) Program the guidance module in the nighttime
4.) Simulate the altitude hold algorithm using realistic sensor errors.

===================3/15/2023==========

All the hooks for telemetry is working and the code compiles.
Need to actually test and see if it works. Starting to worry that
this whole thing is absurdly ambitious. Still lots to do.
Let's see if we can meet the goal.

===================3/13/2023=============

I was able to get the datalogger to work. On the Arduino DUE you need to use Pin 44
as the CS pin but you need to use the SPI interface on the middle of the board
for MISO, MOSI, and CLK.

I also had to edit the datalogger.cpp routine pretty heavily but finally
got it all working. 

Next step according to the calendar is to get the Telemetry to work.
This one will be tough. We need to get both receive and transmit to 
function appropriately. 

===================3/9/2023==============

Currently making progress on Wooden drone
RCINput,RCOUput,GPS, and BaroTemp all work. 
Unfortunately I can't get the SD card logging to work
Going to need to perform some rigorous hardware and 
software testing for that one.

==================3/2/2023================

So for the past few days I've been switching gears yet again and 
making progress on the wooden arduino drone in the lab. This is for the
rocket launch team. They are using a Arduino DUE + Betaflight controller
which means I can finally start working on this. It's about 4 years since
I've touched this. 

==================2/15/2023===============

Still trying to fix this quantization issues.

Testing the apprentice folder right now. Ok apprentice works so we need to test
all vehicles now

1.) Airplane - check
2.) Apprentice - check
3.) car - check
4.) cubesat - check
5.) meta - check
6.) portalcube - check
7.) quadcopter - check
8.) satellite - check (Magnetorquer code is not working but it's already a work task)
9.) tank - check
10.) x8 - check

Alright that means everything works and we can move on to the next step.

==================2/14/2023===============

Working on this double to integer issue that I hacked for the CubeSat.
My plan is to have the actuator flag be 0 for off, 1 for discretization, 2 for dynamics and errors. 

I edited the simulation.txt file to reflect this but I have not edited the code yet. Will have to do that eventually. 

==================1/31/2023===============

Shifting gears and working on some CubeSAT simulations

==================1/30/2023===============

Changed the name to FASTCASST

==================1/6/2023===============

Happy New Year. On the 15th I started working on lowering the timestep. Even at 0.03
the code does not run fast enough. This means we need to look into the following action items and in this order

☐ Fix the double to integer numerical precision issue by adding a quantization flag to the Simulation.txt file. I added a terrible hack where the control_matrix and the pwm_array is sent to every routine and a #ifdef cubesat is there to switch between the two. That's terrible. What we need to do is send the double array to all routines and then somewhere in the model we quantize the array if the flag is set

☐ Try running the integrator on the pi and send data to computer for rendering and create a new mode called RENDER

☐ Dan said it's possible the RK4 vector and control vector are asynchronous and causing issues. Might need to investigate the RK4 state and the control state and see if I'm dealing with that properly. To do that print time,state,control on both desktop and pi and see if you're off. Maxwell had a good idea to lower the timestep to see if that fixes it.

☐ Thread the IMU and GPS

☐ Run SIL on Pi with Desktop mode - As in run FASTKit on Raspbian and do away with Emlid

==================12/15/20222=============

Alright I investigated the issue. I printed the Rk4 time and the watch timer and the integration
is too slow to keep up. Right now the timestep is at 0.01. I'm going to run in SIL mode and 
see how high I can run the timestep before the whole simulation goes unstable

timestep = 0.01 - good
timestep = 0.1 - bad
timestep = 0.05 - bad
timestep = 0.04 - bad but almost made it
timestep = 0.03 - stable

ok 0.03 is the highest I can make it. So let's try HIL at a timestep of 0.03

=====================12/14/2022============

This is what I wanted yesterday.

DESKTOP SIDE
0.) hilupdate -> this will update the control vector and state vector just to be sure everything is up to date with the copies
1.) hilsend -> this sends data to rpi (state vector)
2.) hilreceive -> we then wait for a response from the pi (control vector)
3.) hilupdate -> this will update the control vector and state vector just to be sure everything is up to date with the copies
4.) rk4 -> we run one timestep on the rk4 engine to get a new state vector

Asynchronous option is to have 1-2 run asynchronously and 0 and 3 run synchronously around the rk4 call

PI SIDE
0.) hilupdate -> this will update the control vector and state vector just to be sure everything is up to date with the copies
1.) hilreceive -> we wait for a response from the desktop (state vector)
2.) controller -> we run the controller on the pi
3.) hilsend -> this sends data to the desktop (control vector)

So you see how this is a bit different than what we had before

My suggestion is to work on this at home and then test this on hardware at work

This is what I want today

hil(0)
-DESKTOP - Take state vector and put it into the matrix copy
-PI - wait for update from DESKTOP - will send state vector to copy

hil(1)
-DESKTOP - Send state vector from DESKTOP to PI
-PI - put state vector copy into actual state vector

controller()
-only runs on PI

hil(2)
-DESKTOP - wait for a response from the PI - get control vector
-PI      - put control vector into control vector copy   

hil(3)
-DESKTOP - take control vector copy and put it into memory
-PI      - send control vector copy to DESKTOP

rk4()
-only runs on DESKTOP

or do this, first let's define the functions

hil(0)
-DESKTOP - Take state vector and put it into matrix copy
-PI      - put state vector copy into actual state vector

hil(1)
-DESKTOP - Send state vector copy from DESKTOP to PI
-PI      - send control vector copy from PI to DESKTOP

hil(2)
-DESKTOP - wait for a response from the PI - get control vector
-PI      - wait for update from DESKTOP - will send state vector to copy

hil(3)
-DESKTOP - take control vector copy and put it into memory
-PI      - put control vector into control vector copy

Then the order would be

----TOP----

DESKTOP -> hil(0)
PI -> hil(2)

DESKTOP -> hil(1)
PI -> hil(0)

PI -> controller()

DESKTOP -> hil(2)
PI -> hil(3)

DESKTOP -> hil(3)
PI -> hil(1)

DESKTOP -> rk4()

Ok that's all setup. Let's see if it compiles on DESKTOP. One little public/private error.
We're now running on pi

Ok progress. So the HIL control routine works now. Problem is that the game engine is absurdly slow. Or is it?

I think we need to run SIMONLY with throttle = 992 and aileron=STICK_MAX and see how quickly we hit 180 degrees

Then do it again in SIL mode and see if we get the same

Then do it again in HIL mode. If it turns out we're still having a speed issue it means we need to make
a thread for something.

We also can turn on print statements a bit more and see if perhaps it's the OpenGL routine or the actual RK4
routine.

The watch.currentTime is using the internal clock but the RK4 engine is integrating as fast as possible.

======================12/12/2022==============

Ok looking at the asynchronous nature of the HIL sims. First let's look at the rates

DESKTOP SIDE and RPI side
10.0 	 !Standard Out Print Rate // seconds (set to negative)
0.1  	 !Data logging rate // seconds (numbers if you want)
0.01	 	 !RC Rate // seconds (to run as fast as possible)
0.001 	!Integration rate // seconds

HIL and SERIALLOOP RATE for RPI and DESKTOP
HILRATE = 0.001;
SERIALLOOPRATE = 0.001;

Ok so the standard out print rate of 10.0 is probably good but let's set the datalogging rate and Print rate to 100.0 seconds
The RC rate of 0.01 is probably fine but let's increase the integration rate to 0.01 seconds or 100Hz rather than 1000 Hz

Let's also increase gains to 5.0 and 0.2 since that's the harder setup

Alright. Let's do SIL and make sure everything is working

Let's also plug the computer into power so it runs at full tilt without any power throttling.

Ok SIL worked just fine. Just FYI, an integration rate of 0.1 did not work

Alright let's now try HIL and see what happens

The growth rate is small but the roll channel is still unstable. Before we start adding print statements I want to try something and that's change the HILRATE to 0.01 which is the same as the integration rate. The SERIALLOOPRATE needs to go afap but I don't think the HILRATE which just transfer matrices needs to operate that quickly.

Ok that didn't fix it. Same problem popped up. Interestingly though the instability is changed by airspeed. I'm pressure sure the dynamics change with airspeed. Let's look at the roll dynamics

pdot = L/Ixx -- assuming pure roll about the x-axis

L = La + Lc -- La = aerodynamics and Lc is control

La + Lc = 0.5*rho*v^2*S*Cl
Cl = -Clp*phat + Clda*da

pdot = 0.5*rho*v^2*S*(Clda*da - Clp*phat)/Ixx

then in homogenous form

pdot + 0.5*rho*v^2*S*Clp*phat/Ixx = 0.5*rho*v^2*S*Clda*da/Ixx

So the pole is s = -0.5*rho*v^2*S*Clp/Ixx*a where a is a*p = phat

so yea the dynamics get faster when the velocity increases which means flying slower helps the HIL simulation.

Ok so we need to dig deeper

My plan is to do this. 

1.) Print the roll and roll rate on desktop side and the aileron signal during the dynamic rk4 call
2.) Print the roll, roll rate and aileron signal after control is computed on the pi side

Ok so there's definitely a huge delay in the asynchronous function calls. I wonder if I should try and break the code so that the integrator waits until it hears back from the pi and do away with these asynchronous loops? But just on the desktop side.

Let's make a branch and see what happens

Ok I'm running into some more issues so I need to make the pi side synchronous as well

Ok I think I figured out the problem. The rpi receives a new state vector and then send the old control input because it happens right away.

What we need to do is have the desktop side be asynchronous but the pi side be synchronous but a bit different.

We need to pi to read the new state, compute control and then send the new control vector. That's a bit different than what we had.

I will probably need to revert a bunch of stuff to get that to work properly 

I think what I want to do is have a few routines

DESKTOP SIDE
0.) hilupdate -> this will update the control vector and state vector just to be sure everything is up to date with the copies
1.) hilsend -> this sends data to rpi (state vector)
2.) hilreceive -> we then wait for a response from the pi (control vector)
3.) hilupdate -> this will update the control vector and state vector just to be sure everything is up to date with the copies
4.) rk4 -> we run one timestep on the rk4 engine to get a new state vector

Asynchronous option is to have 1-2 run asynchronously and 0 and 3 run synchronously around the rk4 call

PI SIDE
0.) hilupdate -> this will update the control vector and state vector just to be sure everything is up to date with the copies
1.) hilreceive -> we wait for a response from the desktop (state vector)
2.) controller -> we run the controller on the pi
3.) hilsend -> this sends data to the desktop (control vector)

So you see how this is a bit different than what we had before

My suggestion is to work on this at home and then test this on hardware at work

=====================12/2/2022============

Plotted the data from the flight test yesterday and unfortunately 
the data is inconclusive because we're not logging the rc signals
so....we need to....wait...is it possible to back out the rc signals???

aileron_out = kpa*(roll-roll_command) + kda*(roll_rate)

1.) roll_command = roll - (aileron_out - kda*(roll_rate) ) / kpa
2.) pitch_command = pitch - (elevator_out - kde*pitch_rate) / kpe

Ok so plotting that now....

Also looking at work tasks 

1.) We've already switched from a pi3 to pi4 to try and increase speed
2.) FASTPilot code project has basically been abandoned. The software we've created has basic functionality for inner loop control and there's really no need for FASTPilot. The code thats in FASTpilot may never be used and I don't want to get rid of the repo at the moment but for now there's nothing I want to do with it other than port functionality over to FASTKit. Same with MultiSAT. All that functionality eventually needs to be brought over to FASTKit.
3.) I also emailed my friends over at AREAI to try and speed up HIL

Oh yea and I want to change the name to FASTCAST - Configurable Autopilot and Simulation Tool

I ran into Dr. Russ and he recommended I send data at a baudRate of 115,200
unfortunately I tried that and even edited the code to accommodate two different
baud rates for wireless and wired and it still didn't increase the speed enough
to have HIL work for high gains.

=======================12/1/2022================

We are at irvington at the moment and using

make auto MODEL="apprentice" 

and only inner loop contorl the aircraft flew great with manual and autopilot(innerloop)
control.

Note that we're seeing oscillations in the motor not sure if that's a hardware or software issue
yet.

Moving on to 

make auto MODEL="airplane"

we are moving back to heading angle contorl.

----------Here is where we left off---------------


7.) Moving to heading controller
Current gains are 
  double kp = 0.4;
  double kd = 0.25;
  double ki = 0.02;
Suggest setting ki = 0
Flying with no ki did ok but the problem is that steady state error from the roll axis creeps in and the vehicle kept trying to fly to the right. Suggest adding ki back in but do it slowly at ki = 0.005

------------------------------------------------

My suggestion is actually

kp = 0.4
kd = 0.25
ki = 0.001

Unfortunately motor oscillation did not go away and we scrubbed the flight.

Came back to the lab and oscillations were fully diagnosed. Bad battery so that battery was scrapped. It's odd though because the battery was fully charged so it's obivously something chemical happening in the battery itself.

======================11/11/2022===============

HIL WORKS!!! For the tank at least. It's time to get HIL working on the airplane

1.) Made a new folder for Apprentice
2.) Lowered gains by a factor of 10
3.) simonly works for apprentice
4.) sil works for apprentice
5.) For HIL I need to send RP and GXGY
6.) HIL WORKS!!!!!	

======================11/10/2022===============

Working on running the tank in manual mode to see if HIL works

Tank works in SIL mode both manual and autopilot

In HIL mode I can drive the tank manually but autopilot still doesn't work.

It's almost like packets are being dropped in a weird way but it's odd because 
I can drive the tank just fine when I'm running in manual mode. I'm not sure what's going on.
Perhaps the delay is enough to make it behave erratically

If it's a speed issue I suggest sending RPY only to the Pi and see if that fixes it

Ok so I changed it to only send RPY and now the system oscillates but doesn't freak out.

That means that the issue is speed. So we need to figure out how to speed up the code.

At this point though HIL is finished and I suggest merging the changes in and moving on to
testing to get the system to perform quickly.

I suggest doing what you did before where you turn everything else off except for what's
necessary to see if it works

Changed the yaw controller tank gain from 50 to 5 and it worked. So it's definitely a delay
and speed issue.

We might just need to go back to the airplane and only send RP/GXY and change the gains
to get the inner loop to work. Before you do that though I'd like you to do the following

1.) Run Tank in SIMONLY, SIL, HIL (w/ and w/o telemetry and return rates back to normal) and auto
2.) Merge HIL branch
3.) Then start working on airplane - Only send RP/GXGY and see if you can get airplane to work with HIL. Then paper!!!

======================11/9====================

Alright HIL works just not well enough to run the autopilot.

At 10Hz it just can't keep up. Trying 20Hz. Let's see if the computers can keep up

Tried 100 Hz and it still isn't working

======================11/4 and 7 and 8/2022================

Alright. Time to check the values from controller.cpp and see if we're getting updated values

1.) XYZ - This is updating correctly.
2.) RPY - This is updating correctly
3.) Forward flight speed - This is updating correctly
4.) GXYZ - This is updating correctly

Ok now that that is working properly it's time to switch and have the RPi take data and send the commands over to the Desktop so we can fly the aircraft manually

1.) Change the recOK and sendOK commands to have desktop in perpetual read mode and pi in perpetual send mode
2.) Turn on prints for receiver and make sure Rpi is sending UART PWM commands at 1 Hz for now
3.) Ensure that Desktop is reading PWM commands correctly and sending that to the model
4.) Increase data send rate and data receive rates until you can fly the plane as if it was in SIL mode
5.) Move on to the next step in Work Tasks.tasks

Alright 

1.) Done
2.) Done
3.) Done
4.) Done
5.) Time to move on

======================11/1/2022===============

1.) Working on getting XYZ values to convert properly to Lat and Lon. I think I got GPS working
Need to get barometer now. I think that's done too. Looks like X,Y,Z and Roll, Pitch and Yaw are working properly.
2.) Good I think
3.) Good I think
4.) Good I think

Ok I think the next ones should be fine. They are raw values that don't need processing. So I think we should turn off all the prints on the RPi and then go into the controller.cpp routine and turn on prints for RPi and see if we're getting the right data 

======================10/27/2022==============

Alright. Time to get back to the Rev notes. I'm using an RPi4 with hardwired connection

Ok what we want to do is first have the pi run in HIL mode without getting any data from the computer
and see what happens.

Time - check
time_elapsed - check
Receiver signals - check
RPY - not updating since I'm not sending so that's good
rcoutput - check
Lat/Lon - set to origin - check for now
atmoshpere altitude - check - set to zero
compass - check - set to zero

ok so that's working right. I can check that off. Alright now let's have the RPi get data from the desktop and update the values....

Pause: I just noticed that the RPi is not sending telemetry. Why? Nvm. It is. That's something we need to check later

Ok back to having the Rpi update values: Ok Rpi is receiving data properly. Now we need to make sure everything is being updated properly. So let's do everthing one at a time

1.) X,Y,Z values are being sent over (need to check LAT/LON/ALT and barometer): 
2.) RPY(compass) values are being sent over: 
3.) Forward flight speed is being sent over (will need to check this in the controller.cpp routine): 
4.) GXYZ are being sent over (will also need to check controller.cpp): 

To solve the issue above you need to look at hardware.cpp on line 281

======================10/26/2022==============

1.) Recheck Serial Test - Wired 
RPI to Desktop - works
Desktop to RPI - works
2.) Recheck the HIL Test - Wired - Works
3.) Check Serial Test - Wireless
RPI to Desktop - exactly the same as telemetry - I must have fucked up Serial.cpp because I had to make a separate function for Wireless tranmission from RPI
Desktop to Pi - wireless receive working
4.) Check HIL test - wireless - WORKS!!!!!

Ok I'm home now.

HIL wired at home works. Btw. The RPi at home is an RPi3 and the RPi at work is a 4.

Now testing wireless: Receive on Rpi did the weird thing that was happening yesterday.

Reverting to simple tests for Wireless at home

1.) Serial Test
RPI to Desktop - works
Desktop to RPI - does not work and gives me issues. 

At this point this is just a wireless two way RPi3 communication issue and we don't need that for HIL because 

A.) We're using an RPI4 from now on 
B.) We're using hardline for HIL 
C.) Telemetry at the moment is only 1 way

Ok so we can proceed to HIL steps now.

======================10/25/2022==============

Alright we're working on HIL and it's time to work on works.tasks

1.) First let's make sure HIL test is working. - That's working.
2.) Alright time to have desktop send data 1 way to Rpi. - This is working now. Had to fix some thread locks but I got it.
3.) Now it's time to have the RPi run the control loop with the receiver taking data - Ok this is working no problem but I found a bug unfortunately. Right now it looks like the RPY and basically all data in general is set by the onboard sensors. I need to find the code to ignore that when running in HIL because it needs to get data from the serial port. 
4.) Update sensor data from Serial - code compiles no idea if it works. Just need to keep making progress. Ok so on my bike ride home I didn't like how the routine was running the poll routine for the sensors at all on HIL RPI. Everything should be emulated and the only thing the RPI should be doing is taking inputs and computing outputs. All the filtering and data processing needs to be done on the desktop. So.... I think we're ready to test the next step.
5.) Let's go back to sending data 1 way to RPi and see if we're getting data properly

Ok so Serial and HIL tests don't work. I'm at home with the wireless connection. I can get the Pi to send data to the computer but I can't send data from my computer over to the Pi

Not sure why but it could be a lot of issues. It could be the pi itself or it could be wireless communication.

So.....we need to test 2 things.

1.) Can I send data wirelessly back and forth with the Rpi at work
2.) If I bring the hardwire connection home can I get the home Rpi to send data back and forth

======================10/20/2022==============

Working on HIL and I'm running into a couple communications issues. Like lost packets and such.
so.....

let's see how everything has worked in the past

1.) Full HIL between Processing on Desktop and Arduino - this was just an HIL demo
In this routine Processing would send a string of ALL floats separated by commas. xxx,xxx,xxx,xxx
The arduino would wait for serial to be available and it would read all the floats and then compute control and send it
right back. 
Arduino would read until it received a \n
Processing would read until it received a \n
The arduino would not run the control routine until it received a packet from processing.
The processing code would read the serial over and over until it received data and then once it did it would send data back but it wouldn't send data again until it received a valid packet.

2.) Full HIL between C++ on Desktop and Arduino - This was for JagSAT
C++ on Desktop would send all numbers in the H:XXXXXXX format all at once and then wait for a response from the Arduino. The end of the HEX send would be a \n.
The Arduino then reads all 6 variables at once and parses them all at once
The arduino then sends back all hex vars back all at once
The GetArray routine would read all data from the Arduino at once back to back to back with a for loop

3.) RPi Telemetry C++ over to Processing ground station
RPI sends all numbers all at once over wireless telemetry
Processing would read a number at a time and grab the position of the variable to make sure it got placed in the right spot

4.) RPi Telemetry C++ over to Python Ground Station
Same as above except with Python

Ok so this is what I want to do

a.) Computer sends all numbers all at once to RPi
b.) The RPi will then read each number one at a time and make sure it grabs the proper number for each position
c.) Once the Rpi receives all numbers it will run the control loop and send back the numbers all at once
d.) The computer will wait until it receives a valid response from the RPi before it sends again

GOING BACK TO SERIAL TEST USING HARDWIRE

1.) DESKTOP (C++) -> RPI (Python) - check
2.) RPi (C++) -> DESKTOP (Python) - check
3.) Rpi (C++) -> DESKTOP (C++) - check 
4.) DESKTOP (C++) -> RPI (C++) - check but I need to redo everything because I made a ton of changes

One issue I found was that setting the platform to DESKTOP changed something.
Datalogger - DESKTOP flag not found
MATLAB - DESKTOP flag not found
mathp - DESKTOP flag not found
Serial - DESKTOP flag found but no change would result since SIL is not set
I2Cdev - DESKTOP flag not found
UART - DESKTOP found but no change would result
Util - DESKTOP flag not found
main - DESKTOP flag not found

Ok but I need to look for RPI flag then
MATLAB - RPI not found
mathp - RPI not found
Serial - RPI found and it makes a huge difference
I2Cdev - RPI not found
UAR - RPI found but would not make a difference because functions not called
Util - RPI not found
main - RPI not found

Ok I made a bunch of changes to Serial.cpp to make everything work so I need to start over

1.) DESKTOP (C++) -> RPI (Python) - check
2.) DESKTOP (C++) -> RPI (C++) - check
3.) RPi (C++) -> DESKTOP (Python) - check
4.) Rpi (C++) -> DESKTOP (C++) - check

Alright let's head over to HIL and make sure that works. It works and HIL round trip test is working.

======================10/9/2022==============

Working on HIL. Added a bunch of work tasks into
the Work_Tasks.tasks file. Hopefully that will keep me on track 

Running simonly and the code is broken most likely from
tuning gains below

Ok actually it was because of the barometer calibration

======================10/6/2022==============

1.) Tested inner loop and it works.
Note that barometer was biased by -33 meters. 
2.) Fixed logic in controller.cpp to send negative numbers for icontrol
3.) Added calibration step to barometer so you need to wait 5 seconds now before you fly.
4.) Quite a North wind in Irvington. Did a South side bank at low speed and altitude. Lost lift and control and crashed into the ground. Meta 2 has been totaled. Motors, ESCs, servos and control rods all still in tact. Motor and ESC might be compromised but needs further testing. Airplane tail boom cracked in half and motor mount destroyed. Moving to Meta 1.
5.) Flight test with Meta 1 was a success - Inner loop and velocity test success.
6.) Altitude gains changed to kp = 1.0 and kd = 0.5. 
Gains for altitude seem ok but might need ki gain for integral gain
Since we calibrated the pressure at sea-level we really need to be flying a commanded 50 meters for alttiude
also need to increase kp and ki on velocity controller
Changed Velocity gains to kp = 120. and ki = 8.0
Command altitude set to 50 meters
With new gains on velocity and altitude command the pilot was capable of maintaining a circular loop at a somewhat constant heading. At one point the aircraft was flying into the wind and the aircraft slowed and lost altitude at which point the velocity controller increase and the aircraft began to climb. There was some overshoot so the aircraft controllers needed to slow and then pitch back down. The aircraft dove quite agressively but the aircraft saved itself and maintained an altitude that was still well above the ground.
7.) Moving to heading controller
Current gains are 
  double kp = 0.4;
  double kd = 0.25;
  double ki = 0.02;
Suggest setting ki = 0
Flying with no ki did ok but the problem is that steady state error from the roll axis creeps in and the vehicle kept trying to fly to the right. Suggest adding ki back in but do it slowly at ki = 0.005

======================9/27/2022===============

First flight test of heading loop resulted in significant oscillations

Currently testing the velocity and altitude loop

Altitude using python ground station yields about 30 meters to be appropriate for altitude

Velocity loop controller caused a yaw oscillation. Dr. C has seen this in simulation.
Rudder mixing lowered to kp = 1.0 from 10.0 (which is insane btw)

Velocity command set to 15 m/s and telemetry updated to send speed (GPS) and Altitude (BARO)

Velocity loop suffered no oscillations now and it reached about 9 m/s of velocity when the command is 15 m/s

Tested altitude loop and altitude gains are terrible. Currently kp = 0.2 which means a 30 meter delta
would result in a 6 degree pitch command. Suggest changing kp = 1.5 s.t a 30 meter delta results in 45 degree deflection

Velocity loop tuning by doubling kp and ki (80,3) respectively

Velocity loop test did decently. Can probably increase kp even more. Suggest to 120.

Currently tuning altitude loop suggest kp = 1.5 and kd = 1.0

High frequency pitch oscillations seen in flight with those gains. Suggest lowering kd

It's also possible that kp is too high since large oscillations were seen in pitch.

Suggest kp = 1.0 kd = 0.5 (originall kp = 0.2, kd = 0.1)

Also suggest simulating aircraft with new gains

Winds increased to 12 knots (6.2 m/s) causing almost failure in aircraft. Pilot experienced
loss of control during last flight due to a large gust. If winds gusted to 8 m/s that is 50% of 
the flight speed which is not safe to fly in my opinion.

Current Status
1.) Inner Loop - Check
2.) Velocity Loop - Check (could increase Kp)
3.) Altitude loop - Needs tuning
4.) Heading loop - needs tuning

Back at the lab the code was merged. Unfortunately there is still a model mismatch from the GPS sense and model

======================9/20/2022===============

Creating a separate thread for hil() is a lot harder than
I thought. I am making progress.

If you compile 

make hil_desktop MODEL="airplane" 

you will get the error that the ser and uart vars
are not defined. This is because those variables are in the 
hardware class. In order to access them outside in a standard 
static function like loop and renderloop we need to pass
them to a separate class somehow. You'll need to look up how that's
done in openGL before moving on

Oh and also in order to get telemetry to work alongside with
HIL you'll need to open two serial ports

----Later that day----

Ok I've got two serial ports opening: one for wiring and one for radios
I still have the problem where those serial vars and uart matrices are not
in that function space.

Ok since UART::serHIL is only used inside the hil() routine I just passed the entire
serHIL variable to the function. Hopefully we won't get any runtime seg faults

The only issue now is the uart matrices. Ok I made the uart matrices global and defined them 
externally using extern in the header file and then had them defined in the hardware.cpp file

Ok the code runs but I can't test it until I have the hardware interfaces. We're making progress
though

======================9/18/2022===============

My idea for HIL is to thread the hilSend function

Have the thread constantly reading and writing the array
that it sends back and forth with a mutex.

then in the main loop have the routine pull the newest data
from the array again using a mutex.

Look through the openGL code for help on that.

=======================9/16/2022==============

Trying to fix the airplane code and heading angle controller. Current bugs

1.) Heading offset screws with the heading controller
2.) Turning the heading offset off creates discontinuous jumps. 
3.) Moving to car, the car also has discontinuous jumps in heading
4.) Ground contact model is not creating the correct velocity vectors

FIXING SHIT

1.) Yaw angle is computed from quaternions in floats. I just changed that to doubles. That might 
mess up the auto mode but it did fix the heading angle estimate from the IMU - CHECK?
2.) Ok discontinous heading is gone in the car model
3.) Turned on the heading offset again
4.) Ok looks like heading controller on the plane is working. I think it was the
gain on the rudder

=======================9/6/2022===============

Working on HIL again. This is what works so far and what doesn't work

1.) Sending data from RPI (C++) to DESKTOP (Python) using Radios - Works
2.) Sending data from RPI (C++) to DESKTOP (C++) using Radios - Does not work
3.) Sending data from RPI (C++) to DESKTOP (Python) using Serial USB - So we know the hardwire works.

We need to get the Serial read to work. I do remember HIL working on C++ / Arduino so maybe I need to dig up some old MultiSAT++ code and figure out what's going on and why it won't work.

1.) Sending data from RPI (C++) to DESKTOP (C++) using Serial USB - Then we do this since somehow the python code works and the C++ code does not work.

=======================9/3/2022===============

Just finished adding the car forces and controller. Right now
the system works in waypoint control mode although sensor
errors have not been tested for the car. 

=======================8/23/2022==============

I added a couple comments in the HIL part of the code
to test 1 way communication. The code is pretty much all there
it just needs to be tested

=======================8/18/2022=============

I merged the HIL branch that wasn't completed yet. The last update showing that HIL
worked was on 6/14/2022 just showing that the cable that Maxwell created worked. 
Will need to compile all versions of software first and make sure everything still works.

1.) SIMONLY - Waypoints + Sensor errors - check. Found an issue with the telemetry unit plugged in
2.) SIL - Manual control with XBOX controller - check
3.) SIL - Waypoints - check
4.) AUTO on RPI - check

=======================8/14/2022=============

Alright now it's time to work on SIMONLY control with sensor errors

So an interesting issue with the whole sensor errors issue

Need to actually measure the values of bias, noise and std otherwise all the simulations above are kind of pointless. I'm just randomly putting in values for sensor
errors just to make sure that the code actually works but in order to make sure 
the controller can handle the amount of sensor erorrs that exist in real life we need to actually
put in realistic values which would only come from experimentation.

So it kind of works. The airplane flies waypoints but when the value of heading 
is close to 180 we are still running into that issue where the value of heading
goes from +- to -180. I think I need to rederive that angle compute for dspi. 

I probably have it in Boom somewhere. Actually it was in delpsi.m in MATLAB.git

and then it turns out it was also in mathp.cpp so I just called that function delspi
that already existed and now it works perfectly. 

So freaking awesome. Check that box. haha.

Alright I compiled SIL mode and without sensor errors it worked just fine. Unfortunately
it did not work with sensor errors turned on. Going to have to figure out what exactly is 
making it break.

=======================8/9/2022==============

Alright. I don't have access to HIL since I'm still at home so I'm working on the controller.

I've got a heading angle loop coded for the airplane and it works just fine.

The heading angle controller had a wrapping issue and it's working now.

So now the airplane flies a square pattern

=======================8/2/2022==============

I'm at home from surgery and can't work on HIL right now so I'm adding GPS speed, heading and 
IMU yaw straight from the magnetometer

Done. Not tested on hardware but it's at least possible to put every thing in debug mode with
telemetry and test what's going on 

=======================7/14/2022===============

Yeesh. One month hiatus on HIL. If I recall the issue into was that fact that when no hardware is 
connected the controls default to OUTMIN which is not correct for an airplane. They should default 
to throtte (OUTMIN) and everything else OUTMID. So I need to investigate that issue.

Alright fixed it. Just an issue with reading from serial and my range checks when receiving 
zeros.

One concern I have going forward is that for whatever reason if you read from Serial and you get 
an invalid set of data the controls will revert to defaults. What might be better is to rever to the 
last known values. Hmmmm. Ok I added a backup and revert function. Hopefully that will be ok.

It's time to start testing with hardware again.

=======================6/14/2022===============

Working on HIL. The wired serial USB connector that
Maxwell made works so it's time to start running
HIL on both simulator and hardware

=======================6/13/2022===============

2.) Python ground station reading serial is a check and works. Lags by 2 seconds. I think that's fine.
If I want to fix it. I added it to the future work section
3.) Commit changes - done
4.) Push and make a new branch (5)
5.) See above. Alright donesies

=======================6/6/2022======================

At work. 

1.) Test SIMONLY - pass
SIL - SIL - pass
No need to test HIL because that's sill a work in progress
AUTO on hardware works - PASS
2.) Alright need to get Python to read serial

=======================6/4/2022=======================

Ok the GUI creates a text file and it works in real time with the Python
ground station. This branch is ready to merge.

Alright branch merged. Turns out HIL and Ground_Station branch
were from the same trunk so when I merged Ground_station it merged
both brances. So I deleted Ground_Station and HIL and am operating
dangerously in the main branch. Things to do next time you work on software 
with hardware

1.) Test main in SIMONLY, SIL, AUTO (on hardware)
2.) Test ground station with telemetry radios
3.) Commit changes
4.) Push changes
5.) Branch HIL again

Btw. I also merged in the Wood_Drone branch to not deal with
it for now or this summer and work on it another time

=======================6/2/2022=======================

Alright Python Ground Station is done ish but it needs a few tweaks

1.) I need the GUI to create a text file when it opens and log all the data
it receives
2.) I need to test the GUI with the XBOX controller and see if I can actually fly
the plane in real time. I also think I need a bigger monitor or just an external monitor. So I might just need to test this at work or use my TV in the living room.
Keep in mind once you get back to work you need to add the Serial component to 
the ground station.

-----A few hours later-----

Alright well I've done all can until I have actual hardware.
The XBOX controller to test SIL speed and the telemetry radios to test
reading from USB. I'd say this is ready to merge into the main branch

=======================5/30/2022======================

Alright. Adding text file writing in SIL mode. That is done
it worked pretty slickly if I do say so myself.
Bascially what happens is I used a datalogger class.
During the telemetry write it opens a file. Dumps the 
telemetry contents and then closes it. The next time 
telemetry comes around it just opens a new file. So 
Python just needs to keep a counter and grab either
the latest or the one right before. I'll need to figure out
how to run that logic but we shall see.

I have an idea. It will check to see when x.csv exists.
When it does it will wil open x-1.csv so long as x-1 >= 0

Done. Sweet. Ok so tasks for tomorrow.

2.) Have GUI read data from csv telemetry file (probably do this one at a time first. There are 6 csv files with data in them to test)
3.) Have GUI create text file everytime it receives new data

=======================5/29/2022=======================

Alright time to make the GUI run in realtime with fake
synthetic data. Alright that is done. So yesterday I said
the next step was to make a GUI but I feel like this is good.
To kill the code you need to hit CTRL+C twice which is
not very good programming so I might need to add a q key
stroke but for now I'm going to leave it. I would say the 
next step is to get FASTKit to create a text file when
running in SIL for telemetry. Then have the Ground station
read the latest text file. Once I get back to Mobile
I can create a SerialRead routine to read the live
telemetry data using the Serial module in Python. Unfortuntately
I can't test that here. Actually. If I have the SIL write hex data 
to the text file I can test everything except the serial module

1.) Add text file telemetry writing when running SIL
2.) Have GUI read data from text file
3.) Have GUI create text file everytime it receives new data

=======================5/28/2022=======================

Prototype function for Ground station is done. Next step
is to create subplots and plot everything on one window 
then I want to animate everything using a SIL for loop
Then finally I want to make a GUI

Alright I made one big window and called the routine 
single_window.py

Tomorrow the goal will be to make the GUI run in realtime
with fake synthetic data 

=======================5/27/2022========================

Made a new branch for the Ground Station
What do I want the ground station to do

3 x 3 grid

 Lat/Lon/Alt       |
 Baro Alt          |  MAP (LAT/LON in Cartesion) | Altitude Bars 
 -------------------------------------------------------------------------
 RPY               |   3D Cube                    | Time
 -------------------------------------------------------------------------
 Pitot Speed       |                              
 GPS Speed         |  Bar graphs of RX signals    (both cells)

 Data needed to be sent

 1 - lat -> convert to X
 2 - lon -> convert to Y
 3 - gps alt
 4 - baro pressure -> Convert to altitude
 5 - roll
 6 - pitch
 7 - yaw
 8 - Time
 9  - ADC signal (x2?)
 10 - GPS speed - compute myself? 
 11 - 14/15 - RX signals (4 or 5 signals)

========================5/24/2022========================

Working on HIL again. 
Alright I got the print statements to turn off.
I fixed everything I can fix without using hardware so the next
step is to just test hardware in the loop back and forth

I also edited the rev notes heavily

=========================5/18/2022===========================

I have begun my journey into getting Arduino to Run FASTKit
for the wooden drone. The "hooks" are all in place. It's now just
time to get the cpp files to accommodate ARDUINO specific code.

I am currently trying to get the timer.cpp library added but
obviously I'm having growing pains. 

========================5/16/2022========================

Welcome back from Finals. Whew that was a doozy. Working on HIL
mode right now and it's a mind trip. Right now 

make hil_desktop MODEL="airplane"

compiles and runs but the airplane is spinning like crazy and
there are a ton of stdout prints which I thought I turned off.

Anyway. Made a ton of progress today

========================4/24/2022==========================

SIL on quadcopter and airplane work. Dynamics are poorly tuned
but the simulation itself is working. I'm sure there's a few
bugs but the plots look ok and we just need to move on and get this
paper out. Next step is HIL 

========================4/22/2022==========================

Finished coding the autopilot for the quadcopter. There were a bunch
of issues that I've never encountered before. When the PWM signal
goes to the minimum value you can adequately control roll.
I think some more work needs to be done on this controller
but it's not necessary right now because the goal is to get a conference
paper out the door and a plane in the air. Eventually
though we will need to re investigate this issue. For now
it's time to move on to SIL

========================4/14/2022==========================

Finished coding altitude loop for airplane in simonly. Need to move to
on to simonly autopilot for quadcopter.

========================4/12/2022========================

Finished adding in GPS, Barometer and Thermistor into modeling.cpp
Need to run SIMONLY Quad and Airplane and SIL Quad and Airplane

=========================3/30/2022========================

Ok adding Actuator dynamics or at least attempting to. Ok
finally done. Time to move on to spring goals which means I can 
go back to putting my to do list items in the Work_Tasks file

=========================3/21/2022=========================

Forgot to work on actuator errors. Let's add errors first because
that's easy. ok not so easy. I first need to output the model actuator
value and the signal sent to the motors.

Actuator errors are there and I think adding the dynamics will
just require adding it to the Derivatives routine and the model_matrix
I hope anyway. So here's the to do list

------------TO COMPLETE OLD FUNCTIONALITY----------
2.) Actuator Dynamics
--------------------------------------------------

----------------------SPRING GOALS-----------------
5.) Hardware in the Loop
7.) Higher level autopilot (heading angle and waypoint control)
8.) Python GroundStation
----------------------------------------------------

=========================3/18/2022=========================

Currently working on number 6. I just added rates to everything
to see what is causing such a huge delay. Will need to run software 
in auto mode to see what's going on

PRINT RATE=1.0
BARO=ON
RC,ANALOG,LOGGIN=0.1
GPS,TELEMETRY=100.0
elapsedTime = 0.0015ish

PRINT,TELEMETRY=1.0
BARO=ON
RC,ANALOG,LOGGING=0.1
GPS=100.0
elapsedTime = 0.0018-0.0022 (Still no noticeable lag)

PRINT,TELEMETRY=1.0
BARO=ON
RC,ANALOG,LOGGING=0.1
GPS=0.1
elapsedTime = 0.1 (Lag is noticeable)

In reality we don't want to update GPS over 1 second anyway maybe even 2 seconds

PRINT,TELEMETRY=1.0
BARO=ON
RC,ANALOG,LOGGING=0.1
GPS=1.0
elapsedTime = 0.0018-0.0022 (No noticeable lag)
IMU,Control,PWM = 1/inf

If you want to increase rates from there you will have to thread.
Note that IMU, Control Loop and PWM out are running as fast as possible

While we are here let's go ahead and test the autopilot. Ok the autopilot works
which means the code now runs as fast as we need it to and for the time
being we don't need to speed up the code. I'm going to pause on the threading
for now since I fixed the lag issue. I can thread the IMU and GPS and maybe
even the PWM loop if needed but for now the loop timer is good.

So here is the current to do list. My goal is to do number 2 over
the weekend and then start working on HIL next week....wait.
I need to discuss the HIL stuff with Maxwell first.

------------TO COMPLETE OLD FUNCTIONALITY----------
2.) Actuator Dynamics/Errors
--------------------------------------------------

----------------------SPRING GOALS-----------------
5.) Hardware in the Loop
7.) Higher level autopilot (heading angle and waypoint control)
8.) Python GroundStation
----------------------------------------------------

=========================3/16/2022==========================

Sensor errors is done. Only thing left for old functionality
is Actuator Dynamics/Errors

------------TO COMPLETE OLD FUNCTIONALITY----------
2.) Actuator Dynamics/Errors
--------------------------------------------------

----------------------SPRING GOALS-----------------
5.) Hardware in the Loop
6.) Threading all sensors with the boost library - (NEED TO FIX THE LAG!!!)
7.) Higher level autopilot (heading angle and waypoint control)
8.) Python GroundStation
----------------------------------------------------

========================3/14/2022=========================

AUTO mode is now working and telemetry also works. However
there is a ridiculous amount of lag that I've never encountered
before and I'm not sure what needs to be done to make it better. So
here are the current action items

------------TO COMPLETE OLD FUNCTIONALITY----------
2.) Actuator Dynamics/Errors
4.) Sensor Errors
--------------------------------------------------

----------------------SPRING GOALS-----------------
5.) Hardware in the Loop
6.) Threading all sensors with the boost library - (NEED TO FIX THE LAG!!!)
7.) Higher level autopilot (heading angle and waypoint control)
8.) Python GroundStation
----------------------------------------------------

========================3/11/2022=======================

Alright I fixed the Sense matrix issue. Also Maxwell fixed the 
telemetry radios so I need to test the TELEMETRY on Monday.
Here's what I can work on this weekend.

------------TO COMPLETE OLD FUNCTIONALITY----------
2.) Actuator Dynamics/Errors
4.) Sensor Errors
--------------------------------------------------

========================3/9/2022============================

I tried fixing the sense matrix and model matrix issue and 
I am still having trouble with it. Run plotdata.py and you'll
see what I mean.

========================3/1/2022============================

AUTO mode was tested right before spring break. Telemetry
has been coded and just needs to be tested. If all that works
ANTX will be done. After that it's time to start working 
on Spring goals. Ok actually old functionality really needs
to be completed first. I just found a pretty big issue
In order to test the issue try switching into autopilot
The problem is that the Sense Matrix report Q0123 rather 
than RPY

Added X8, Satellite and Tank Dynamics. Gonna update the list from
2/22 because I found a pretty major issue.

------------FOR ANTX-----------------------
0.) Test AUTO and TELEMETRY on Bench test with 
Processing Ground Station including autopilot.
Might need to fix item 3 below as well
----------------------------------------------

------------TO COMPLETE OLD FUNCTIONALITY----------
2.) Actuator Dynamics/Errors
3.) Sense Matrix needs to be 29x1 with RPY and quaternions
from model matrix needs to be converted to RPY. This 
has the potential for breaking quite a bit of stuff.
4.) Sensor Errors
--------------------------------------------------

----------------------SPRING GOALS-----------------
5.) Hardware in the Loop
6.) Threading all sensors with the boost library
7.) Higher level autopilot (heading angle and waypoint control)
8.) Python GroundStation
----------------------------------------------------

========================2/24/2022========================

0.) AUTO mode for airplane on bench top works. Just need to add telemetry
and then ANTX is ready.

========================2/22/2022========================

Keyboard is working now and airplane dynamics are working.
Shall we add the quad dynamics? May as well. Quad dynamics have
been added. Here's the rest of the actions in no particular order

------------FOR ANTX-----------------------
0.) AUTO mode on bench top
1.) Telemetry with Processing Ground Station
-----------------------------------------

------------TO COMPLETE OLD FUNCTIONALITY----------
2.) Actuator Dynamics/Errors
3.) Satellite, X8, and Tank Dynamics
4.) Sensor Errors
--------------------------------------------------

----------------------SPRING GOALS-----------------
5.) Hardware in the Loop
6.) Threading all sensors with the boost library
7.) Higher level autopilot (heading angle and waypoint control)
8.) Python GroundStation
----------------------------------------------------

========================2/21/2022==========================

Alright time to add opengl. I had a huge boost library issue
but everything is fine now. There are a few other issues
with opengl like right now it starts at 1 second and the portal
cube shoots straight up oh and the keyboard doesn't work

1.) Starts at 1 second - Fixed
2.) Shoots straight up - Fixed
3.) keyboard doesn't work 
4.) Gravity model and ground contact model - Fixed

Need to work on the keyboard after this

========================2/13/2022==========================

Added a datalogger to the modeling class and edited the python script
to plot both. That makes the data file way freaking easier.

I can add the dynamics of the specific vehicle OR
the environment OR
opengl.

Not sure what I want to do but that's on the agenda.

Ok so dynamics require the environment so we either do opengl
or we do the environment. I guess we can do the environment.

Alright the environment has been added. Now we can add the dynamics

Dynamics have been added. The only thing left is the opengl model
and of course threading which I'm not looking forward to. The kids are
crying I will probably leave that for another day. 

=========================2/11/2022===========================

Added datalogger to hardware block. Need to add a datalogger to
modeling block. also added dynamics. Still need environment  

=========================1/24/2022==============================

Started working on simonly. Hardware block is slowly building up.
I think controller and hardware block are done. Need to build up
modeling environment in simonly then add opengl for sil

Crap. There's no datalogger right now. :(

Now that I think about it the auto mode will work on the RPi.

So i need to test

logger, demo and auto on the rpi and debug.

simonly and sil are still needed for the laptop simulation.

==========================1/21/2022=============================

The loggersil scripts works in Desktop and RPI but the logger
script doesn't work on RPI. I think it was because I didn't
initialize the IMU so I added that in. I just need to test it.

I just finished coding the demosil script and it works. Again I just
need to test it on the RPI in demo mode.

Next to do item is to get simonly working which will be quite a
bit to get up and running because I have to get the entire dynamics
routine operational. I can at least start with the overall flow of
simonly and then slowly build it up. 

==========================1/19/2022=============================

Ok I finally started working on this code. The beginning of the semester 
was pretty tough. I started to realize that the C++ repo was about to get
horribly messed up and I knew I was going to rename it so instead I decided to 
just make a new repo. So that's this repo now called FASTkit. 

I will probably keep the C++ repo open just for archive purposes but my 
plan is to not use it anymore. 

===========================1/2/2022==========================

Happy New Year. I finally created the Youtube videos for SysML and 
uploaded them to this repo. The code is now ready to be broken, built back 
up and turned into software that looks like the SysML diagram.

===========================12/31/2021=========================

I made all the SysML diagrams on paper so the next step is to actually
create the diagrams on the computer and make a screen cast about it.

===========================12/30/2021=========================

Alright the aerodynamics model standard has been changed to external
forces and moments for any vehicle. The next item on the agenda is to 
code a CubeSAT in LEO and deprecate the Orbit++ model from aerospace.git

Ok CubeSAT LEO model works. Just need to deprecate Orbit++ in aerospace
Took all day man.

Ok the Orbit++ model has been deprecated. Next step is SysML analysis.
so you just need your notebook.

===========================12/29/2021=========================

I have started breaking the code. I have moved a lot of files 
all over the place. Right now I have folders for SIM, DEMO and LOGGER
but I cannot test DEMO or LOGGER nor can I test AUTO or HIL because I
do not have the hardware. I will just have to cross that bridge next 
week. Everything I want to do with the make file is done though so it's
time to move on to the next task in the main .tasks file
Next task is to rename all the aerodynamics.cpp files to forces.cpp

============================11/17/2021========================

FASTSim works on Tank, Quadcopter and X8 now in AUTO mode and SIMONLY/SIL
I could test it on the plane but that seems superfluous since we're 
going to fly the quads/X8 first. I guess if ANTX comes out of nowhere
we can run FASTSim on the BatWing

============================9/30/2021======================

Alot has changed in the code. Simpilot is almost fully operational
and the rcout class has been completely overhauled. I am currently tuning the
controller right now in simulation and should have something working properly 
in a day or so.

==============================9/25/2021======================

Haven't been commenting here very much but I am starting to work on the rcout 
class. It's moving slow but I have a branch called RCOUTPUT and I for right now
have rcout working in SIMONLY and SIL mode which isn't saying much because it doesn't
do anything in that mode. The real test will be AUTO mode

=============================9/15/2021=========================

Added controller.* for quadcopter into Simpilot. All that's left is to add
the RCOUT commands and Simpilot will be done.

==============================9/14/2021===========================

Added a very crude aerodynamic model to the quadcopter model and also added a super simple autopilot
loop to the controller.cpp file. Need to now copy it over into SimPilot. 
Haven't touched the work tasks because I haven't done it on the pi just yet.

==============================9/13/2021===============================

Maxwell's ground contact model has been merged. 
The actuator dynamics branch has been merged.
Software has been cleaned up a bit and SimPilot got a clean compile
SimPilot is now in FASTSim in its own folder
RCInput works with XBOX controller both in the RCtest and in Simpilot.
The IMU on Desktop works as well. Working on the Controller for a quadcopter
right now.

==============================9/12?/2021==============================

I forgot to take notes on this but I overhauled the crap out of the plotting routine.
I need to keep working on it to actually test the actuator model.

Ok process logs works without actuators. Let's....wait. Let's add sensor errors
first.

Sensor errors works. It kind of worries me because well the controller doesn't do
too well but then again this is a dumb contorller on a Portalcube

Alright. Time to turn on actuators....Well after a bit of tinkering. Actuator dynamics
is working. Time to merge :|

==============================9/7/2021=================================

MORE EDITS TO FASTSim for actuator dynamics. Now is the time to try and compile and get rid of compilation errors. Then it is time for run time errors.

Code now compiles so it's time for runtime errors

Code compiles and runs without actuators. Need to get plotting routine working

==============================9/6/2021==================================

Started working on actuator dynamics. Kind of a bear. Since I stopped halfway through I have probably breaked the fuck out the code but just run it in debug mode. What you need to do is get the logger to log the right number of variables and add the actuator states to the integrator

Ok I think actuator dynamics are ready but you need to run through code line by line before you even attempt to compile and run because there is no way this shit is going to work

I would say the next thing you need to do is run through the main.cpp
routine and make sure everything is passed through correctly especially 
with actuator dynamics on or off

The other thing that is currently totally messed up is the way the system logs data
I think the integrator has the 6DOF states and the actuator states but the sensor measurements only have the 6DOF states. I'm assuming it does not have the actuator states. But if we're running the RK4 I'd like to know the control signals, the actuator state and the actuator error state. So I need to figure out how to do that.

==============================9/3/2021===================================

With the help of Maxwell I was able to fix the sensor errors issue.
Turns out it was massive issue that required fixing in MATLAB.cpp (quat2euler)
and in Dynamics.cpp to normalize the quaternions

==============================8/27/2021=================================

Added a quadcopter model to the simulation using a camo texture. Nothing fancy

Copied the portalcube aerodynamics file and controller file over to the quadcopter

still need to edit it to be accurate to a quad but at least it's in there

==============================8/17/2021=================================

Cleaned up and overhauled these rev_notes and the work_tasks.

Also added a #ifdef RK4_H to main.cpp

==============================7/29/2021==================================

Created a HIL.git on Github and moved all hardware related routines over there
May end up moving the Sensors routine over there as well and maybe the Datalogger
routine but I haven't decided.

Anyway when I did that I made sure everything was still working properly

===============================6/22/2021 ================================

Still need to keep working on actuator dynamics above but I moved this to 
a README file.

Just FYI. I was working on FASTLogger and the IMU, ADC, GPS and BARO
all work now. Yay.

Ok first things first. Time to break the code for FASTSim.

Alright I got rid of make_links and added all the appropriate -I's in the makefile. It looks a lot better now.

Next is to move the Navio folder over to a Navio Archive folder. To do that
I need to ssh into the Navio in my home.

Ok I cp'ed the current Navio folder to a NavioOG folder and deleted all
custom made routines that way it is preserved as is and is never touched. I pushed that to the master

I then tested all the C++_Examples but I made its own folder called Examples. If you open up NavioOG you'll see how much nicer it looks

Then I took alll of the Navio blocks and placed them into appropriate folders in C.git. You'll notice that FASTSim uses RCInput from C.git on my Github but FASTPilot et al uses RCInput from Navio2. This means there's a duplicate and this is very bad. So I organized all of the routines even if they don't compile. There is no Navio folder now. All of the modules are within other folders. There is a NavioOG folder that has all of the original routines to make sure you can go back and test worst case

With everything royally messed up I made sure FASTSim and FASTLogger compile on both laptop and desktop

Now both FASTLogger and FASTSim work with the new folder structure.

Problem is that the -L and -I's are insane and I think it's time to
make those a bit cleaner so we need to do yet another overhaul.....

I did one more overhaul where I used the <> instead of the "" so the -I and -L are cleaner

================================================================================

4/30/2021 - Long time no see. I am here fixing the plotting routine because for some reason the commands from the controller are printing correctly but the actual values are not. Currently investigating the issue here. Ok false alarm. Turns out those values were actually from the RX which are always empty anyway in SIMONLY mode.

Ok so it's time to continue working on Actuator dynamics. So I looked at what I did and I don't like it. In my opinion the user should only be in charge of the following things. 

actuator values -> Forces produced by those values

So what we need to do is the following. 

1.) Integrate the state vector to produce State.
2.) Send STate to the sensor routine and receive the polluted state
3.) Send pollutted state to controller built by the user to produce ctlcomms
4.) Send ctlcomms to actuator dynamics to produce actuators values
5.) Pollute actuator values with ACTUATOR ERRORS by some percentage
6.) Send actuator values to aerodynamics routine written by user to produce Forces and moments

Ok let's get started. 

1.) Integrate state vector to produce state. That's done in the integrator.state
line of code so we're done there.
2.) Send State to the sensor routine to receive polluted state. I think this is maybe 
in the vehicle.loop routine but I'm not sure. Grading now so will have to check
later

===================================================================================

4/1/2021 - Been busy. Started writing a README to get up and running because it's been a while. I also started doing this revision "Add separate input file folders and have argv grab the root directory of your input files including the objs and stuff". So I finished the README and I got the input files to work properly which is nice. Collin also sent me an X8 model. The textures are super messed up but hey it's a start

2/26/2021 - Added RCTECH USB contorller in the lab to FASTsim. To get this to work you need to run RCInput by iself and make sure the mapping is set up correctly. Then change the stick min and max values in RCINput.h and then add a -D to the makefile for this controller

Also tried to import a UAM cad modle but it has wayyyy too many vertices and no texture for mapping

2/9/2021 - When I compiled SIMONLY on the RPI it turns out that I didn't have the -DRPI directive in place. So I had to fix a few things. It is working now which is nice.

My plan for actuator dynamics is this - In some input file you need to tell the dynamics routine the number of actuators and the time constant of each one. Then it will run through a for loop and integrate those dynamics The first order filter equation is as follows actuator_var_dot = time_constant*(actuator_command - actuator_var) So the question then is what is the actuator command???? Is this from the controller?? On line 184 of Dynamics.cpp I send ctl.ctlcomms to the aero model. So what I need to do is send the cltcomms to a first order filter and then send state.actuator_var to the aero model So I had the aerodynamics.h routine set the number of actuators rather then set it in the input files so all you need to do is create a public variable in aerodynamics.h and the have the dynamics routine use that to create dynamics. Seems simple enough

2/4/2021 - Compiled SIMONLY on RPI. Only thing you need to do is get rid of OPENGL in the Makefile and the make_links script. 

1/29/2021 - Add polling rates for the Receiver and the control loop. I think that's every
thing we need for polling rates. I would say the next thing to work on is actuator dynamics.
For actuator dynamics I'm not entirely sure how I want to do this. So forces in this routine
are all in the aerodynamics model. So I think we need to have an extra error value (in percent)
in the simulation flags portion and then send it to the aero model. Let's try that. Oh ok wait 
this is for actuator errors. Lol. Let's just do that anyway right now. Ok not entirely sure if it's exactly how I want it but actuator errors are in the sim now. It's in the aerodynamics model which I'm not too crazy about. I'd rather it be in maybe the dynamics class or something but I'm not sure what to do here. At least the hooks are in there properly. So the last thing I need to do is add the actuator dynamics. Can you tell I've been delaying the crap out of it?

1/28/2021 - Sensors errors have been added. It doesn't necessarily work and there's a ton
of holes in the system but hey you can add sensor errors and sensor noise and you can plot
the output of those sensors. Anyway the next thing to add in my opinion is the control
cycle. That seems like an easy thing to add

1/27/2021 - Still kind of upset at how last night went I created a simple quadcopter.obj
and threw it into FASTPilot. That's a private repo but the fact is you can make your own
obj file provided you use the same format as the cube that's in this repo.

1/26/2021 - Added some comments to make sure I know what to do next. I made a CAD for a 
quadcopter but it sucks. I downloaded a *.blend from the internet and tried to make an
OBJ but it just looks terrible. I did learn alot though. What you need to do is add a 
texture to the UV tab. Then select all the vertices in edit of your object and hit U 
for unwrap. Once you do that you can export everything to an OBJ. If you did it right
you will see v for vertices vn for normals vt for texture vertices and then f for face
in the format f v/vt/vn. The quadcopter I did create was so freaking big that the 
integrator would just kind of keep integrating in the background before you could
see what was happening. So I created a wait loop in the main routine here to cross_sleep
until the opengl routine was operational. My recommendation is to get a better CAD model
by just building a CAD model yourself or getting a grad student to do it.

1/25/2021 - Changed the default camera to follow the first object in the series which if
you set it up correctly is the main object. I also added a zaxis offset to the camera in
render.txt file so now you can have the camera slightly above the ground. I also added a
ground plane check. When you're below the ground and with a negative zdot you stop. It's
not completely tested but at least it somewhat works for now. I would say the sim is ready
to add the quadcopter obj and dynamic model. 

1/10/2021 - Added full autopilot for portal cube, I have not coded a stabilize mode but I
I think I know how to do it. If you hold the left joystick you can turn the autopilot on
and off just like a trainer switch. I also created a mapping function to map the joystick
keys to standard receiver inputs

1/9/2021 - Test aerodynamics and autopilot. Autopilot is not completely done but I'm making
progress

1/8/2021 - Alright I added placeholders for aerodynamics and controller models with 
hooks in place. We basically need to test everything I just wrote. My vote is to get
the fictitious sensors to work. After that my vote is to work on the aircraft autopilot.
Then to work on the quad autopilot

1/7/2021 - Added 6DOF dynamic model. Added RCInput class but it is not 
implemented. My suggestion is to make a bare bones aerodynamic model first 
and test open loop

1/6/2021 - opengl model is finally working and ready to go!!!

1/5/2021 - Added opengl but system does not move. Still need to add boost 
threads to get this to work properly

1/2/2021 - Added point mass model on flat earth, added environment class. 
Fixed some compilation flags.

1/1/2021 - Added Datalogger, RK4 routine and point mass model in space using 
Dynamics class

12/10/2020 - Added Loop timer




















